import matplotlib.pyplot
import networkx
import numpy as np
from relax import nonzeroColumnMethodRelaxation
from random_strategy import greedyInitialStrategy
from math import atan2, cos, sin, sqrt, radians
from xml.dom import minidom
from compute_real_optimal_attacker import compute_real_optimal_attacker
import argparse
from compare_defender_utilities_script import calculate_percent_difference

def calc_distance(origin, destination):
    """
    title::
        calc_distance
    
    description::
        Great-circle distance between two points on a sphere from their longitudes
        and latitudes.
    
    author::
        Stackoverflow User: user2514381
        https://stackoverflow.com/questions/17273120/distance-calculation-in-python-for-google-earth-coordinates
    """
    lat1, lon1 = origin
    lat2, lon2 = destination
    radius = 6371 # km. earth

    dlat = radians(lat2-lat1)
    dlon = radians(lon2-lon1)
    a = (sin(dlat/2) * sin(dlat/2) + cos(radians(lat1)) * cos(radians(lat2)) *
             sin(dlon/2) * sin(dlon/2))
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    d = radius * c

    return d

def case_study(kmlFile,
               kappa,
               gamma,
               N,
               k,
               l,
               distanceThreshold=5,
               plotGraph=False,
               outFile=None,
               robustnessTest=False,
               skipTitle=None):
    """
    title::
        case_study

    description::
        This method runs the case study in our AAAI 2020 paper. Leads to
        Fig. 3h in paper. Note that U_dc, U_du, U_ac, U_au are hard coded 
        based on values from paper (see Appendix D.1). Please feel free to 
        change. An option is also provided to run very preliminary robustness
        tests on gamma (only off by 0.1) and utilities. To generate plots in
        Appendix, simply run for multiple values of gamma.

    attributes::
        kmlFile
            Path to KML file that contains locations of potential poaching
            interest. We used 10 locations (and utilities are hard coded for 
            10 targets), so if wishing to use more than 10, be sure to modify
            the provided utilities.
        kappa
            Kappa parameter in uncertainty matrix, defined in paper (Sec. 3.1),
            generates uncertainty matrix here as follows:
            uncertaintyMatrix = np.array([[1,     kappa,       0],
                                          [0,     1-kappa,     0],
                                          [0,     0.00,      1]])
        gamma
            False negative rate
        N
            Number of targets (graph size)
        k
            Number of human patrollers
        l
            Number of drones
        distanceThreshold
            Threshold (km) for determining whether an edge should be present 
            [default is 5]
        plotGraph
            True if display graph generated by KML and distance thresholding, 
            as well as final plot [default is False]
        outFile
            Path to which to save plot, or None if prefer not to write 
            [default is None]
        robustnessTest
            Whether to run preliminary robustness test on utilities and gamma 
            (note: just prints values, no plots) [default is False]
            NOTE: This is the primary testing used to support the claim in the 
            paper. This was run multiple times and in general, changes were 
            small, though sometimes they are larger. We believe this is due to
            different attacker behaviors being selected sometimes, but think
            this is an interesting direction for future work. We added the 
            robustnessTest option to compare_defender_utilities_script to 
            allow for further testing on more varied cases. Also, please note
            that percent change was used for the paper, but we include percent
            difference here similar to the robustnessTest option added to 
            compare_defender_utilities_script.
        skipTitle
            Title of file to skip in KML file if necessary [default is None]

    author::
        Elizabeth Bondi (ebondi@g.harvard.edu)
        Hoon Oh, Haifeng Xu, Kai Wang
        Stackoverflow User: user2514381
        https://stackoverflow.com/questions/17273120/distance-calculation-in-python-for-google-earth-coordinates
    
    disclaimer::
        This source code is provided "as is" and without warranties as to 
        performance or merchantability. The author and/or distributors of 
        this source code may have made statements about this source code. 
        Any such statements do not constitute warranties and shall not be 
        relied on by the user in deciding whether to use this source code.
      
        This source code is provided without any express or implied warranties 
        whatsoever. Because of the diversity of conditions and hardware under 
        which this source code may be used, no warranty of fitness for a 
        particular purpose is offered. The user is advised to test the source 
        code thoroughly before relying on it. The user must assume the entire 
        risk of using the source code.
    """
    #Initialize.
    uncertaintyMatrix = np.array([[1,     kappa,       0],
                                [0,     1-kappa,     0],
                                [0,     0.00,      1]])
    assumedGamma = 0
    assumedUncertaintyMatrix = np.array([[1.0,   0,   0],
                                        [0,   1,   0],
                                        [0,   0,   1]])
    eta =[[0,0,0],[1,0,0],[0,1,0],[0,0,1],[1,1,0],[1,0,1],[0,1,1],[1,1,1]]
    maxIteration = max(500, N*N/5)

    #Parse KML file.
    #https://stackoverflow.com/questions/17273120/distance-calculation-in-python-for-google-earth-coordinates
    xmldoc = minidom.parse(kmlFile)
    kml = xmldoc.getElementsByTagName("kml")[0]
    document = kml.getElementsByTagName("Document")[0]
    placemarks = document.getElementsByTagName("Placemark")

    nodes = {}
    for placemark in placemarks:
        nodename = placemark.getElementsByTagName("name")[0].firstChild.data
        if (skipTitle is not None) and (skipTitle in nodename):
            continue
        coords = placemark.getElementsByTagName("coordinates")[0].firstChild.data
        lst1 = coords.split(",")
        longitude = float(lst1[0])
        latitude = float(lst1[1])
        nodes[nodename] = (latitude, longitude)

    #Create graph from KML file.
    edges = []
    for m in nodes:
        for n in nodes:
            if n == m:
                continue
            if calc_distance(nodes[m], nodes[n]) < distanceThreshold:
                edges.append((int(m),int(n)))

    G=networkx.Graph()
    for e in edges:
        G.add_edge(e[0],e[1])

    degrees = [x[1] for x in list(G.degree(G.nodes()))]
    maxDegree = max(degrees)

    #Plot resulting graph if desired.
    if plotGraph:
        matplotlib.pyplot.figure()
        matplotlib.pyplot.title('Nodes')
        pos = networkx.spring_layout(G, k=0.05)
        networkx.draw_networkx(G, 
                               pos=pos, 
                               node_color='g', 
                               alpha=0.8, 
                               font_size=22, 
                               with_labels=True, 
                               node_size=500)
        matplotlib.pyplot.axis('off')
        matplotlib.pyplot.tight_layout()

    #Hard code utilities from paper.
    U_dc = np.asarray((29,55,42,38,33,51,64,59,46,24)).astype(np.float64)
    U_du = np.asarray((-3200,
                       -12800,
                       -8000,
                       -6400,
                       -4800,
                       -11200,
                       -16000,
                       -14400,
                       -9600,
                       -1600)).astype(np.float64)
    U_au = np.asarray((120,
                       320,
                       240,
                       160,
                       80,
                       280,
                       400,
                       400,
                       200,
                       40)).astype(np.float64)
    U_ac = np.zeros(10, dtype=np.float64) - 20

    defEU = []
    #Uniform random estimate: first find max attEU target, then calculate defEU.
    attEURandom = U_au * ((N - (2 * k) - l) / float(N)) + \
                U_ac * ((2 * k) / float(N)) + \
                U_ac * ((l * k * maxDegree) / float(N))
    attTarget = np.argmax(attEURandom)

    defEURandom = U_du[attTarget] * ((N - (2 * k) - l) / float(N)) + \
                U_dc[attTarget] * ((2 * k) / float(N)) + \
                U_dc[attTarget] * ((l * k * maxDegree) / float(N))
    defEU.append(defEURandom)

    #Ignore (detection) uncertainty.
    initialStrategies = greedyInitialStrategy(G,k,l,U_dc,U_du,U_ac,U_au)
    resBoth, variables, cpx, count, strategies, bestEtaBoth, \
                bestTargetBoth = \
                    nonzeroColumnMethodRelaxation(N,
                                                k,
                                                l,
                                                G,
                                                assumedGamma,
                                                eta,
                                                assumedUncertaintyMatrix,
                                                U_dc,
                                                U_du,
                                                U_ac,
                                                U_au,
                                                initialStrategies,
                                                randomSeed=False,
                                                maxIteration=maxIteration)
    recalc, rtgt, ra = compute_real_optimal_attacker(N,
                                    variables,
                                    strategies,
                                    G,
                                    uncertaintyMatrix,
                                    gamma,
                                    U_dc,
                                    U_du,
                                    U_ac,
                                    U_au)
    defEU.append(recalc)

    #No drones.
    initialStrategies = greedyInitialStrategy(G,k,0,U_dc,U_du,U_ac,U_au)
    resBoth, variables, cpx, count, strategies, bestEtaBoth, \
                bestTargetBoth = \
                    nonzeroColumnMethodRelaxation(N,
                                                k,
                                                0,
                                                G,
                                                gamma,
                                                eta,
                                                assumedUncertaintyMatrix,
                                                U_dc,
                                                U_du,
                                                U_ac,
                                                U_au,
                                                initialStrategies,
                                                randomSeed=False,
                                                maxIteration=maxIteration)
    defEU.append(resBoth)
    
    #Both.
    initialStrategies = greedyInitialStrategy(G,k,l,U_dc,U_du,U_ac,U_au)
    resBoth, variables, cpx, count, strategies, bestEtaBoth, \
                bestTargetBoth = \
                    nonzeroColumnMethodRelaxation(N,
                                                k,
                                                l,
                                                G,
                                                gamma,
                                                eta,
                                                uncertaintyMatrix,
                                                U_dc,
                                                U_du,
                                                U_ac,
                                                U_au,
                                                initialStrategies,
                                                randomSeed=False,
                                                maxIteration=maxIteration)
    defEU.append(resBoth)

    #Brief analysis for when utilities or gamma are slightly different from 
    #estimated values (not included in paper).
    if robustnessTest:
        #First, recalculate if utilities are slightly off.
        U_dc_real = U_dc + 10 
        U_du_real = U_du - 10
        U_ac_real = U_ac - 10
        U_au_real = U_au + 10
        recalc, rtgt, ra = compute_real_optimal_attacker(N,
                                        variables,
                                        strategies,
                                        G,
                                        uncertaintyMatrix,
                                        gamma,
                                        U_dc_real,
                                        U_du_real,
                                        U_ac_real,
                                        U_au_real)
        
        print('Original objective value: ', resBoth)
        print('New objective value if recalculated with "true" utilities: ', 
                recalc)
        print('Percent difference: ', calculate_percent_difference([resBoth, 
                                                                    recalc]))


        #Check if gamma is only slightly off, rather than completely ignored 
        #(i.e., gamma=0 in previous tests).
        gamma -= 0.1
        if gamma < 0:
            gamma = 0
        recalc, rtgt, ra = compute_real_optimal_attacker(N,
                                        variables,
                                        strategies,
                                        G,
                                        uncertaintyMatrix,
                                        gamma,
                                        U_dc,
                                        U_du,
                                        U_ac,
                                        U_au)
        print('Original objective value: ', resBoth)
        print('New objective value if recalculated with "true" (-0.1) gamma: ',
                recalc)
        print('Percent difference: ', calculate_percent_difference([resBoth, 
                                                                    recalc]))


    labels = ["Random", 
              "Def. Ignore\nUncertainty", 
              "No Drones\n($k=1, l=0$)", 
              "GUARDSS"]
    matplotlib.pyplot.rcParams.update({'font.size':22})
    matplotlib.pyplot.figure()
    matplotlib.pyplot.ylabel("Defender's Expected Utility")
    matplotlib.pyplot.bar(0, defEU[0], 0.75)
    matplotlib.pyplot.bar(1, defEU[1], 0.75, hatch="/")
    matplotlib.pyplot.bar(2, defEU[2], 0.75, hatch="+")
    matplotlib.pyplot.bar(3, defEU[3], 0.75, hatch="x")
    matplotlib.pyplot.xticks([0,1,2,3], labels, rotation=45)
    if plotGraph:
        matplotlib.pyplot.show()
    elif outFile is not None:
        matplotlib.pyplot.tight_layout()
        matplotlib.pyplot.savefig(outFile, bbox_inches='tight')
    
if __name__ == '__main__':
    
    parser = argparse.ArgumentParser(description='Run case study experiment.')
    parser.add_argument('kmlFile', type=str, 
                        help='Path to KML file containing poaching locations.')
    parser.add_argument('-ka', '--kappa', type=float, 
                        default=0,
                        help='Value to construct uncertainty matrix.')
    parser.add_argument('-g', '--gamma', type=float, 
                        default=0.8,
                        help='False negative rate.')
    parser.add_argument('-n', '--N',
                        type=int, 
                        default=10,
                        help='Number of targets (N) in graph.')
    parser.add_argument('-k', '--k', type=int,
                        default=1,
                        help='Number of human patrollers (k).')
    parser.add_argument('-l', '--l', type=int,
                        default=3,
                        help='Number of drones (l).')
    parser.add_argument('-d', '--distanceThreshold',
                        type=int, default=5,
                        help='Threshold (km) for determining edge presence.')
    parser.add_argument('-p', '--plotGraph',
                        help='Include to display graph and plot.',
                        default=False,
                        action='store_true')
    parser.add_argument('-o', '--outFile',
                        default=None,
                        help='Path to which to save plot.')
    parser.add_argument('-r', '--robustnessTest',
                        help='Include to run basic robustness test and print.',
                        default=False,
                        action='store_true')
    parser.add_argument('-s', '--skipTitle',
                        default=None,
                        help='Title of file to skip in KML file if necessary.')
    args = parser.parse_args()
    case_study(args.kmlFile,
               args.kappa,
               args.gamma,
               args.N,
               args.k,
               args.l,
               args.distanceThreshold,
               args.plotGraph,
               args.outFile,
               args.robustnessTest,
               args.skipTitle)